<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>基于原型链的撤销/重做系统</title>
  <style>
    body {
      font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
    }
    
    h1, h2, h3 {
      color: #2c3e50;
    }
    
    .demo-container {
      margin: 20px 0;
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background-color: #f9f9f9;
    }
    
    .controls {
      margin-bottom: 15px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    button:hover {
      background-color: #2980b9;
    }
    
    button:disabled {
      background-color: #95a5a6;
      cursor: not-allowed;
    }
    
    .color-btn {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 0 3px rgba(0,0,0,0.3);
    }
    
    .size-controls {
      display: flex;
      align-items: center;
      margin-left: 10px;
    }
    
    .size-controls label {
      margin-right: 5px;
    }
    
    #canvas {
      border: 1px solid #ccc;
      background-color: white;
      display: block;
      margin: 0 auto;
    }
    
    #state-display {
      margin-top: 15px;
      padding: 10px;
      background-color: #f1f1f1;
      border-radius: 4px;
      font-family: monospace;
      white-space: pre-wrap;
    }
    
    .explanation {
      margin: 30px 0;
      padding: 15px;
      background-color: #e8f4fc;
      border-left: 4px solid #3498db;
      border-radius: 0 4px 4px 0;
    }
    
    code {
      background-color: #f8f8f8;
      padding: 2px 5px;
      border-radius: 3px;
      font-family: Consolas, Monaco, 'Andale Mono', monospace;
      color: #e74c3c;
    }
    
    pre {
      background-color: #f8f8f8;
      padding: 15px;
      border-radius: 5px;
      overflow-x: auto;
    }
    
    .object-diagram {
      margin: 20px 0;
      padding: 15px;
      background-color: #f5f5f5;
      border-radius: 8px;
      border: 1px dashed #ccc;
    }
    
    .object-box {
      border: 2px solid #3498db;
      border-radius: 8px;
      padding: 10px;
      margin: 10px;
      background-color: white;
      display: inline-block;
      vertical-align: top;
      min-width: 200px;
    }
    
    .object-title {
      background-color: #3498db;
      color: white;
      padding: 5px 10px;
      margin: -10px -10px 10px -10px;
      border-radius: 6px 6px 0 0;
      font-weight: bold;
    }
    
    .object-props {
      font-family: monospace;
      margin-bottom: 10px;
    }
    
    .proto-link {
      color: #e74c3c;
      font-style: italic;
      border-top: 1px dashed #ccc;
      padding-top: 5px;
    }
    
    .arrow {
      display: inline-block;
      margin: 0 10px;
      color: #7f8c8d;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>基于原型链的撤销/重做系统</h1>
  
  <div class="explanation">
    <p>这个演示展示了如何利用JavaScript原型链实现高效的撤销/重做功能。预置的形状直接以对象方式存在原型链上，而不是使用数组组织。改动时基于原型链重新生成对象。</p>
  </div>
  
  <h2>绘图演示</h2>
  <div class="demo-container">
    <div class="controls">
      <button id="undoBtn" disabled>撤销</button>
      <button id="redoBtn" disabled>重做</button>
      <button id="clearBtn">清空</button>
      
      <div style="margin-left: auto; display: flex; align-items: center;">
        <span style="margin-right: 10px;">颜色:</span>
        <button class="color-btn" style="background-color: #e74c3c;" data-color="#e74c3c"></button>
        <button class="color-btn" style="background-color: #3498db;" data-color="#3498db"></button>
        <button class="color-btn" style="background-color: #2ecc71;" data-color="#2ecc71"></button>
        <button class="color-btn" style="background-color: #f39c12;" data-color="#f39c12"></button>
      </div>
      
      <div class="size-controls">
        <label for="size-slider">大小:</label>
        <input type="range" id="size-slider" min="5" max="50" value="20">
      </div>
    </div>
    <canvas id="canvas" width="500" height="300"></canvas>
    <p>点击画布添加圆形，尝试更改颜色和大小，然后使用撤销/重做操作。</p>
    <div id="state-display"></div>
  </div>
  
  <div class="object-diagram">
    <h3>对象结构示意图</h3>
    <div class="object-box">
      <div class="object-title">BasePrototype (原型对象)</div>
      <div class="object-props">
        color: "#3498db"<br>
        radius: 20<br>
        borderWidth: 2<br>
        circle1: {x: 50, y: 50}<br>
        circle2: {x: 150, y: 100}<br>
        circle3: {x: 250, y: 150}<br>
        square1: {x: 350, y: 50, w: 40, h: 40}<br>
        getMetadata(): {...}<br>
        clone(): {...}
      </div>
    </div>
    <div class="arrow">←</div>
    <div class="object-box">
      <div class="object-title">State1 (历史栈中的状态)</div>
      <div class="object-props">
        // 覆盖原型上的形状<br>
        circle1: {x: 70, y: 60}<br>
        // 添加新形状<br>
        circle4: {x: 400, y: 200}<br>
        id: "abc123"<br>
        modified: "2023-11-15..."
      </div>
      <div class="proto-link">__proto__ → BasePrototype</div>
    </div>
    <div class="arrow">←</div>
    <div class="object-box">
      <div class="object-title">State2 (新状态)</div>
      <div class="object-props">
        // 继承State1的修改<br>
        circle1: {x: 70, y: 60}<br>
        circle4: {x: 400, y: 200}<br>
        // 新的修改<br>
        circle2: null, // 删除circle2<br>
        circle5: {x: 300, y: 250}<br>
        id: "def456"<br>
        modified: "2023-11-15..."
      </div>
      <div class="proto-link">__proto__ → BasePrototype</div>
    </div>
  </div>
  
  <h2>核心实现原理</h2>
  <pre><code>// 创建基础原型对象，预置形状直接作为属性
const BasePrototype = {
  // 共享的基础属性
  color: "#3498db",
  radius: 20,
  borderWidth: 2,
  borderColor: "#2c3e50",
  shadow: true,
  shadowColor: "rgba(0,0,0,0.3)",
  shadowBlur: 5,
  
  // 预置的形状，直接作为属性存在原型上
  circle1: { x: 50, y: 50, type: 'circle' },
  circle2: { x: 150, y: 100, type: 'circle' },
  circle3: { x: 250, y: 150, type: 'circle' },
  square1: { x: 350, y: 50, width: 40, height: 40, type: 'rect' },
  
  // 共享的方法
  getMetadata() {
    return {
      color: this.color,
      radius: this.radius,
      borderWidth: this.borderWidth,
      borderColor: this.borderColor,
      shadow: this.shadow
    };
  },
  
  // 获取所有可见形状
  getShapes() {
    const shapes = {};
    
    // 遍历所有属性，找出形状对象
    for (const key in this) {
      const value = this[key];
      if (value && typeof value === 'object' && value.type) {
        shapes[key] = value;
      }
    }
    
    return shapes;
  },
  
  clone() {
    // 创建一个新对象，继承原型
    const cloned = Object.create(Object.getPrototypeOf(this));
    
    // 只复制自有属性，不复制原型上的属性
    for (const key in this) {
      if (this.hasOwnProperty(key)) {
        if (this[key] && typeof this[key] === 'object') {
          // 深拷贝对象
          cloned[key] = JSON.parse(JSON.stringify(this[key]));
        } else {
          cloned[key] = this[key];
        }
      }
    }
    
    return cloned;
  }
};

// 冻结原型对象，防止修改
Object.freeze(BasePrototype);

class HistoryManager {
  constructor() {
    // 创建初始状态，基于BasePrototype
    const initialState = Object.create(BasePrototype);
    initialState.id = this.generateId();
    initialState.modified = new Date().toISOString();
    
    // 初始化历史栈和当前索引
    this.history = [initialState];
    this.currentIndex = 0;
  }
  
  // 执行操作
  execute(action) {
    // 如果当前不在历史栈顶，截断历史栈
    if (this.currentIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.currentIndex + 1);
    }
    
    // 获取当前状态
    const currentState = this.getCurrentState();
    
    // 克隆当前状态创建新状态
    const newState = currentState.clone();
    
    // 更新新状态的元数据
    newState.id = this.generateId();
    newState.modified = new Date().toISOString();
    
    // 应用操作
    action(newState);
    
    // 添加到历史栈并更新索引
    this.history.push(newState);
    this.currentIndex++;
    
    return this.getCurrentState();
  }
  
  // 更新基础配置
  updateBaseConfig(newConfig) {
    // 创建新的原型对象，基于当前原型
    const newProto = Object.create(null);
    
    // 复制当前原型的所有属性
    for (const key in BasePrototype) {
      newProto[key] = BasePrototype[key];
    }
    
    // 应用新配置
    for (const key in newConfig) {
      newProto[key] = newConfig[key];
    }
    
    // 冻结新原型
    Object.freeze(newProto);
    
    // 为所有历史状态设置新原型
    this.history.forEach(state => {
      Object.setPrototypeOf(state, newProto);
    });
  }
  
  // 撤销操作
  undo() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
    }
    return this.getCurrentState();
  }
  
  // 重做操作
  redo() {
    if (this.currentIndex < this.history.length - 1) {
      this.currentIndex++;
    }
    return this.getCurrentState();
  }
  
  // 获取当前状态
  getCurrentState() {
    return this.history[this.currentIndex];
  }
  
  // 生成唯一ID
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
  }
  
  // 获取历史信息
  getInfo() {
    return {
      canUndo: this.currentIndex > 0,
      canRedo: this.currentIndex < this.history.length - 1,
      historyLength: this.history.length,
      currentIndex: this.currentIndex
    };
  }
}</code></pre>

  <h2>设计特点</h2>
  <div class="explanation">
    <p>这个实现有以下特点：</p>
    <ol>
      <li><strong>预置形状直接存在原型上</strong> - 形状作为BasePrototype的直接属性，而不是数组中的元素</li>
      <li><strong>形状以键值对方式组织</strong> - 每个形状有唯一的键名(circle1, circle2等)，便于引用和修改</li>
      <li><strong>状态只存储差异</strong> - 每个状态只存储与原型不同的形状（修改、添加或删除）</li>
      <li><strong>形状可以被覆盖或删除</strong> - 可以通过设置null来"删除"原型上的形状</li>
      <li><strong>原型链共享数据</strong> - 所有状态对象通过原型链共享基础数据和未修改的形状</li>
      <li><strong>克隆机制</strong> - 改动时通过clone()方法基于原型链重新生成对象</li>
    </ol>
  </div>

  <script>
    // 创建基础原型对象，预置形状直接作为属性
    const BasePrototype = {
      // 共享的基础属性
      color: "#3498db",
      radius: 20,
      borderWidth: 2,
      borderColor: "#2c3e50",
      shadow: true,
      shadowColor: "rgba(0,0,0,0.3)",
      shadowBlur: 5,
      
      // 预置的形状，直接作为属性存在原型上
      circle1: { x: 50, y: 50, type: 'circle' },
      circle2: { x: 150, y: 100, type: 'circle' },
      circle3: { x: 250, y: 150, type: 'circle' },
      square1: { x: 350, y: 50, width: 40, height: 40, type: 'rect' },
      
      // 共享的方法
      getMetadata() {
        return {
          color: this.color,
          radius: this.radius,
          borderWidth: this.borderWidth,
          borderColor: this.borderColor,
          shadow: this.shadow
        };
      },
      
      // 获取所有可见形状
      getShapes() {
        const shapes = {};
        
        // 遍历所有属性，找出形状对象
        for (const key in this) {
          const value = this[key];
          if (value && typeof value === 'object' && value.type) {
            shapes[key] = value;
          }
        }
        
        return shapes;
      },
      
      clone() {
        // 创建一个新对象，继承原型
        const cloned = Object.create(Object.getPrototypeOf(this));
        
        // 只复制自有属性，不复制原型上的属性
        for (const key in this) {
          if (this.hasOwnProperty(key)) {
            if (this[key] && typeof this[key] === 'object') {
              // 深拷贝对象
              cloned[key] = JSON.parse(JSON.stringify(this[key]));
            } else {
              cloned[key] = this[key];
            }
          }
        }
        
        return cloned;
      }
    };

    // 冻结原型对象，防止修改
    Object.freeze(BasePrototype);

    class HistoryManager {
      constructor() {
        // 创建初始状态，基于BasePrototype
        const initialState = Object.create(BasePrototype);
        initialState.id = this.generateId();
        initialState.modified = new Date().toISOString();
        
        // 初始化历史栈和当前索引
        this.history = [initialState];
        this.currentIndex = 0;
      }
      
      // 执行操作
      execute(action) {
        // 如果当前不在历史栈顶，截断历史栈
        if (this.currentIndex < this.history.length - 1) {
          this.history = this.history.slice(0, this.currentIndex + 1);
        }
        
        // 获取当前状态
        const currentState = this.getCurrentState();
        
        // 克隆当前状态创建新状态
        const newState = currentState.clone();
        
        // 更新新状态的元数据
        newState.id = this.generateId();
        newState.modified = new Date().toISOString();
        
        // 应用操作
        action(newState);
        
        // 添加到历史栈并更新索引
        this.history.push(newState);
        this.currentIndex++;
        
        return this.getCurrentState();
      }
      
      // 更新基础配置
      updateBaseConfig(newConfig) {
        // 创建新的原型对象，基于当前原型
        const newProto = Object.create(null);
        
        // 复制当前原型的所有属性
        for (const key in BasePrototype) {
          newProto[key] = BasePrototype[key];
        }
        
        // 应用新配置
        for (const key in newConfig) {
          newProto[key] = newConfig[key];
        }
        
        // 冻结新原型
        Object.freeze(newProto);
        
        // 为所有历史状态设置新原型
        this.history.forEach(state => {
          Object.setPrototypeOf(state, newProto);
        });
      }
      
      // 撤销操作
      undo() {
        if (this.currentIndex > 0) {
          this.currentIndex--;
        }
        return this.getCurrentState();
      }
      
      // 重做操作
      redo() {
        if (this.currentIndex < this.history.length - 1) {
          this.currentIndex++;
        }
        return this.getCurrentState();
      }
      
      // 获取当前状态
      getCurrentState() {
        return this.history[this.currentIndex];
      }
      
      // 生成唯一ID
      generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
      }
      
      // 获取历史信息
      getInfo() {
        return {
          canUndo: this.currentIndex > 0,
          canRedo: this.currentIndex < this.history.length - 1,
          historyLength: this.history.length,
          currentIndex: this.currentIndex
        };
      }
    }

    // 初始化画布
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const stateDisplay = document.getElementById('state-display');
    const sizeSlider = document.getElementById('size-slider');
    
    // 创建历史管理器
    const drawingManager = new HistoryManager();
    
    // 渲染函数
    function render(state) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 重置阴影，避免影响其他元素
      ctx.shadowBlur = 0;
      
      // 获取所有形状
      const shapes = state.getShapes();
      
      // 渲染所有形状
      for (const key in shapes) {
        const shape = shapes[key];
        
        if (shape.type === 'circle') {
          // 绘制圆形
          ctx.beginPath();
          ctx.arc(shape.x, shape.y, state.radius, 0, Math.PI * 2);
          
          // 设置阴影（如果启用）
          if (state.shadow) {
            ctx.shadowColor = state.shadowColor;
            ctx.shadowBlur = state.shadowBlur;
          }
          
          // 填充
          ctx.fillStyle = state.color;
          ctx.fill();
          
          // 边框
          if (state.borderWidth > 0) {
            ctx.lineWidth = state.borderWidth;
            ctx.strokeStyle = state.borderColor;
            ctx.stroke();
          }
        } else if (shape.type === 'rect') {
          // 绘制矩形
          ctx.beginPath();
          
          // 设置阴影（如果启用）
          if (state.shadow) {
            ctx.shadowColor = state.shadowColor;
            ctx.shadowBlur = state.shadowBlur;
          }
          
          // 填充
          ctx.fillStyle = state.color;
          ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
          
          // 边框
          if (state.borderWidth > 0) {
            ctx.lineWidth = state.borderWidth;
            ctx.strokeStyle = state.borderColor;
            ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
          }
        }
      }
      
      // 重置阴影
      ctx.shadowBlur = 0;
      
      // 更新状态显示
      updateStateDisplay();
    }
    
    // 更新状态显示
    function updateStateDisplay() {
      const info = drawingManager.getInfo();
      const state = drawingManager.getCurrentState();
      const shapes = state.getShapes();
      
      // 计算自有属性和原型属性
      const ownProps = Object.keys(state).length;
      const protoProps = Object.keys(Object.getPrototypeOf(state)).length;
      const shapeCount = Object.keys(shapes).length;
      
      // 构建形状列表
      let shapeList = '';
      for (const key in shapes) {
        const shape = shapes[key];
        const isOwn = state.hasOwnProperty(key);
        shapeList += `  ${key}: ${shape.type} at (${shape.x},${shape.y}) ${isOwn ? '[覆盖]' : '[原型]'}\n`;
      }
      
      stateDisplay.textContent = 
        `当前状态: 有 ${shapeCount} 个形状\n` +
        `历史长度: ${info.historyLength} 项\n` +
        `当前索引: ${info.currentIndex}\n` +
        `状态ID: ${state.id}\n` +
        `修改时间: ${state.modified}\n` +
        `自有属性: ${ownProps} 个\n` +
        `原型属性: ${protoProps} 个\n` +
        `当前颜色: ${state.color}\n` +
        `当前大小: ${state.radius}\n\n` +
        `形状列表:\n${shapeList}`;
    }
    
    // 更新按钮状态
    function updateButtons() {
      const info = drawingManager.getInfo();
      document.getElementById('undoBtn').disabled = !info.canUndo;
      document.getElementById('redoBtn').disabled = !info.canRedo;
    }
    
    // 生成唯一的形状ID
    let nextShapeId = 5; // 从5开始，因为已经有circle1-3和square1
    function generateShapeId() {
      return `circle${nextShapeId++}`;
    }
    
    // 点击画布添加圆形
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      drawingManager.execute(state => {
        // 创建新形状并添加到状态
        // 注意：这里直接作为属性添加，而不是放入数组
        const shapeId = generateShapeId();
        state[shapeId] = { x, y, type: 'circle' };
      });
      
      render(drawingManager.getCurrentState());
      updateButtons();
    });
    
    // 撤销按钮
    document.getElementById('undoBtn').addEventListener('click', () => {
      render(drawingManager.undo());
      updateButtons();
    });
    
    // 重做按钮
    document.getElementById('redoBtn').addEventListener('click', () => {
      render(drawingManager.redo());
      updateButtons();
    });
    
    // 清空按钮
    document.getElementById('clearBtn').addEventListener('click', () => {
      drawingManager.execute(state => {
        // 获取所有形状
        const shapes = state.getShapes();
        
        // 将所有形状设为null，相当于"删除"
        for (const key in shapes) {
          state[key] = null;
        }
      });
      render(drawingManager.getCurrentState());
      updateButtons();
    });
    
    // 颜色按钮
    document.querySelectorAll('.color-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const color = btn.getAttribute('data-color');
        drawingManager.updateBaseConfig({ color });
        render(drawingManager.getCurrentState());
      });
    });
    
    // 大小滑块
    sizeSlider.addEventListener('input', () => {
      const radius = parseInt(sizeSlider.value);
      drawingManager.updateBaseConfig({ radius });
      render(drawingManager.getCurrentState());
    });
    
    // 初始化
    updateButtons();
    render(drawingManager.getCurrentState());
  </script>
</body>
</html>
